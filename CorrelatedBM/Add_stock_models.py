"""
Modify in stock_model.py. Here we actually just add to the class BlackScholes the method
generate_correlated_paths.
"""

class BlackScholes(StockModel):
    """
    standard Black-Scholes model, see:
    https://en.wikipedia.org/wiki/Blackâ€“Scholes_model
    https://en.wikipedia.org/wiki/Geometric_Brownian_motion
    """
    def __init__(self, drift, volatility, nb_paths, nb_steps, S0,
                 maturity, sine_coeff=None, **kwargs):
        super(BlackScholes, self).__init__(
            drift=drift, volatility=volatility, nb_paths=nb_paths,
            nb_steps=nb_steps, S0=S0, maturity=maturity,
            sine_coeff=sine_coeff
        )

    def next_cond_exp(self, y, delta_t, current_t):
        return y * np.exp(self.drift*self.periodic_coeff(current_t)*delta_t)

    def generate_paths(self, start_X=None):
        drift = lambda x, t: self.drift*self.periodic_coeff(t)*x
        diffusion = lambda x, t: self.volatility * x
        spot_paths = np.empty(
            (self.nb_paths, self.dimensions, self.nb_steps + 1))
        dt = self.maturity / self.nb_steps
        if start_X is not None:
            spot_paths[:, :, 0] = start_X
        for i in range(self.nb_paths):
            if start_X is None:
                spot_paths[i, :, 0] = self.S0
            for k in range(1, self.nb_steps + 1):
                random_numbers = np.random.normal(0, 1, self.dimensions)
                dW = random_numbers * np.sqrt(dt)
                spot_paths[i, :, k] = (
                        spot_paths[i, :, k - 1]
                        + drift(spot_paths[i, :, k - 1], (k-1) * dt) * dt
                        + np.dot(diffusion(spot_paths[i, :, k - 1], (k) * dt),
                                 dW))
        # stock_path dimension: [nb_paths, dimension, time_steps]
        return spot_paths, dt

    def generate_correlated_paths(self, start_X=None, rho=0.):
        """
        Generates correlated paths.
        Arguments:
            start_X (see generate_paths)
            rho (float): float between 0. and 1.
        Return:
            spot_paths (np.array): paths generated by the Black-Scholes model.
            spot_paths2 (np.array): paths generated by the Black-Scholes model
                and correlated to spot_paths.
            dt (array like): time range
        """
        if (rho > 1.) or (rho < 0.):
            raise ValueError("rho should be 0. <= rho <= 1.")

        drift = lambda x, t: self.drift*self.periodic_coeff(t)*x
        diffusion = lambda x, t: self.volatility * x
        spot_paths = np.empty(
            (self.nb_paths, self.dimensions, self.nb_steps + 1))
        spot_paths2 = np.empty(
            (self.nb_paths, self.dimensions, self.nb_steps + 1))
        dt = self.maturity / self.nb_steps
        if start_X is not None:
            spot_paths[:, :, 0] = start_X[0]
        if start_X is not None:
            spot_paths2[:, :, 0] = start_X[1]
        for i in range(self.nb_paths):
            if start_X is None:
                spot_paths[i, :, 0] = self.S0
                spot_paths2[i, :, 0] = self.S0
            for k in range(1, self.nb_steps + 1):
                random_numbers = np.random.normal(0, 1, self.dimensions)
                random_numbers2 = np.random.normal(0, 1, self.dimensions)

                dW = random_numbers * np.sqrt(dt)
                dW2 = (random_numbers * rho + np.sqrt(1 - rho**2) * random_numbers2) * np.sqrt(dt)
                spot_paths[i, :, k] = (
                        spot_paths[i, :, k - 1]
                        + drift(spot_paths[i, :, k - 1], (k-1) * dt) * dt
                        + np.multiply(diffusion(spot_paths[i, :, k - 1], (k) * dt),
                                 dW))
                spot_paths2[i, :, k] = (
                        spot_paths2[i, :, k - 1]
                        + drift(spot_paths2[i, :, k - 1], (k-1) * dt) * dt
                        + np.multiply(diffusion(spot_paths2[i, :, k - 1], (k) * dt),
                                 dW2))

        return spot_paths, spot_paths2, dt
